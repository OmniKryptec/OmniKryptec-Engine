#module util

@h>
vec3 lighting(vec3 Scol, vec3 toCamVector, vec3 toLightVector, vec3 normal, vec3 Mdiff, vec3 Mspec, float Mdamp, vec4 attenuation, vec4 lightConeInfo, vec4 lightPosition, vec3 coneAttenuation);
@h<

/**
*if lightPosition.w equals 0.0 this light will be a directional light
*
*
*
*/
vec3 lighting(vec3 lightColor, vec3 toCamVector, vec3 toLightVector, vec3 normal, vec3 Mdiff, vec3 Mspec, float Mdamp, vec4 attenuation, vec4 lightConeInfo, vec4 lightPosition, vec3 coneAttenuation){
	float distance = length(toLightVector);
	//directional light -> lightpos is the light direction
	if(lightPosition.w==0.0){
		toLightVector = -lightPosition.xyz;
	}
	vec3 toLightNormalized = normalize(toLightVector);
	vec3 unitCam = normalize(toCamVector);
	vec3 fromLight = -toLightNormalized;


	float dot1 = saturate(dot(normal,toLightNormalized));
	vec3 diffusev = dot1 * lightColor;

	vec3 reflected = reflect(fromLight, normal);
	float dot2 = saturate(dot(reflected, unitCam));
	float damp = 0;
	//if no diffuselight there will be no specular light
	if(dot1>0.0){
		damp = pow(dot2, Mdamp);
	}
	vec3 spec = damp * lightColor * Mspec;




	float attenu = 1.0/(attenuation.x + (attenuation.y * distance) + (attenuation.z * distance * distance));
	if(attenuation.w>-1&&distance>attenuation.w){
		attenu = 0;
	}
	//directional light
	if(lightPosition.w==0.0){
		attenu = 1.0;
	}else{
		//point- or spotlight
		float ltsa = dot(fromLight, normalize(lightConeInfo.xyz));
		//current point is outside the lightcone
		if(ltsa < lightConeInfo.w){
			attenu = 0.0;
		}else{
			float disfac = (ltsa - lightConeInfo.w)/(1.0 - lightConeInfo.w);
			disfac = coneAttenuation.x + coneAttenuation.y * disfac + coneAttenuation.z * disfac * disfac;
			attenu = attenu * disfac;
		}
	}
	attenu = min(attenu, 1.0);
	return (diffusev*Mdiff+spec)*attenu;
}

